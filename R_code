#### AR1 Example
### Approximate hyperparameter posterior marginals using:
### initial approximation (LDS-QA), then
### update with a Cubic Correction

library(INLA)    #For inla-related functions

### Korobov Lattice

shift.koro = function(n.pts, dimension, gen_constant, shift){
    n = n.pts; s = dimension; a = gen_constant; v = runif(s,0,1)
    z.korob = vector(length = s)
    z.korob[1] = 1
    for (j in 1:(s-1)){
        z.korob[j+1] = (z.korob[j] * a) %% n
    }
    korob = array(dim = c(n,s))
    if(shift == TRUE){
        for (k in 0:(n-1)){
            korob[k+1,] = (((k/n)*z.korob) + v) %% 1
        }
    } else {
        for (k in 0:(n-1)){
            korob[k+1,] = ((k/n)*z.korob) %% 1
        }
    }
    return(korob)
}

trans.pset = function(points, low, high){
    ## Transform from unit hypercube to hyper-cuboid

    vec = vector(length=length(low))
    for (i in 1:length(vec)){
        vec[i] = high[i]-low[i]
    }
    t.pset = array(dim = dim(points))
    for(j in 1:nrow(points)){
        for(i in 1:ncol(points)){
            t.pset[j,i] = vec[i]*points[j,i] + low[i]
        }}
    return(t.pset)
}

#Functions

### Kullback-Liebler divergence function

kl.div = function(true.dist,approx.dist)
{	if(length(true.dist) != length(approx.dist))
	{message("Try again mate!")}
	else{
	n = length(true.dist)
	try = cbind(true.dist,approx.dist)
	h = apply(try,2,sum)
	try.again = cbind(try[,1]/h[1], try[,2]/h[2])	#Normalising
	kld = vector(length=n)
	for(i in 1:n)
	{
		kld[i] = log(try.again[i,1]/try.again[i,2])*try.again[i,1]
	}
	return(sum(kld))
}} 

###### Density Functions ########

### Scaled-Beta [Beta with support (-1,1)]

scaledBeta = function(x, a, b, log=FALSE)
{
    ## the input 'x' is in the interval (-1, 1)
    xx = (x + 1)/2
    f = dbeta(xx, shape1=a, shape=b, log=TRUE) - log(2)
    return (if (log) f else exp(f))
}

### Partitioning functions..

meanBetween = function(vec){
	meanVec = vector(length = length(vec) - 1)
	for(i in 1:length(meanVec)){
		meanVec[i] = 0.5*(vec[i] + vec[i+1])
		}
	return(meanVec)
	}

partition = function(mat, support, nPart, position){
	parts = seq(support[1], support[2], length.out = nPart+1)
	m.vec = vector(length = nPart)
	m.pos = vector(length = nPart) 
	for(i in 1:nPart-1){		###FINDING AVERAGES
		m.vec[i] = mean(subset(mat[,2], mat[,1] >= parts[i] & mat[,1] < parts[i+1]))
		}
	m.vec[nPart] = mean(subset(mat[,2], mat[,1] >= parts[nPart] & mat[,1] <= parts[nPart+1]))
						###POSITIONING
	if(position == 0){
		m.pos = parts[1:nPart]
	} else if(position == 1){
		m.pos = parts[2:(nPart+1)]
	} else{
		m.pos = meanBetween(parts)
		}
	return(cbind(m.pos, m.vec))
	}

vandermonde.matrix = function(x.pts, degree){
	x = x.pts; y = 0:degree
	v = outer(x,y,"^")
	return(v)
	}

### For function evaluations! ###

inla.evaluate = function(theta, result){

    ## re-evaluate the model at fixed configuration 'theta'. return the new result.
    result$.args$control.mode = list(theta = theta, x = result$mode$x, fixed = TRUE)
    return (do.call("inla", args = result$.args))
}

### AR1 model
### 3 hyperparameters, tau, kappa, rho

n = 100
s = 0.1
set.seed(781984); x = arima.sim(n, model = list(ar = 0.65))
x = scale(x)
y = x + rnorm(n, sd = s)
data = data.frame(y, x, idx = 1:n)
r = inla(y ~ -1 + f(idx, model="ar1",
                   ## this is 0.65 in the internal scale
                   hyper = list(rho = list(initial = 1.550597, fixed=FALSE,
                                           prior = "betacorrelation",
                                           param = c(5, 1)),
                                prec = list(prior = "loggamma",
                                            param = c(1, 1)))), 
         data = data,
         family = "gaussian",
         control.family = list(hyper = list(
                                   prec = list(
                                       fixed = FALSE,
                                       initial = log(1/s^2),
                                       prior = "loggamma",
                                       param = c(100, 1)))), 
         control.inla = list(int.strategy = "eb", reordering = "metis"))

r2 = inla.hyperpar(r, diff.logdens = 20)

### SUPPORT BOUNDS ###
### Using INLA approximations

### 1) Fit inla.spline to inla theta approximation
### 2) Take a marginal support where a_i and b_i contain the bulk of the density
### 3) construct box out of these "bounds"

### INLAs (inla.hyperpar) approximations to theta and HP for support!

limit = 0.001

### INLA Theta/HP 1

theta.inla.hyperpar1.list = inla.smarginal(r2$internal.marginals.hyperpar[[1]])
theta.inla.hyperpar1.mat = cbind(theta.inla.hyperpar1.list$x, theta.inla.hyperpar1.list$y)
theta.inla.hyperpar1 = subset(theta.inla.hyperpar1.mat, theta.inla.hyperpar1.mat[,2] >= limit)
inla_hyperpar1 = r2$marginals.hyperpar[[1]]

### INLA Theta/HP2
theta.inla.hyperpar2.list = inla.smarginal(r2$internal.marginals.hyperpar[[2]])
theta.inla.hyperpar2.mat = cbind(theta.inla.hyperpar2.list$x, theta.inla.hyperpar2.list$y)
theta.inla.hyperpar2 = subset(theta.inla.hyperpar2.mat, theta.inla.hyperpar2.mat[,2] >= limit)
inla_hyperpar2 = r2$marginals.hyperpar[[2]]

### INLA Theta/HP3
theta.inla.hyperpar3.list = inla.smarginal(r2$internal.marginals.hyperpar[[3]])
theta.inla.hyperpar3.mat = cbind(theta.inla.hyperpar3.list$x, theta.inla.hyperpar3.list$y)
theta.inla.hyperpar3 = subset(theta.inla.hyperpar3.mat, theta.inla.hyperpar3.mat[,2] >= limit)
inla_hyperpar3 = r2$marginals.hyperpar[[3]]

theta.names = names(r$marginals.hyperpar)
len.theta = length(theta.names)
est.theta = r$mode$theta   # Mode value(s) estimate (from inla function)
cov.intern = r$misc$cov.intern # Covariance matrix estimate from inla.

cat("We have ", len.theta, "hyperparmaeters\n")
for(nm in theta.names) {
    cat("\t- ", nm, "\n")
}

cat("Estimates are ")
cat(est.theta, "\n")
cat("With Covariance matrix\n")
print(cov.intern)


### compute the reference (without the priors on the hyperparameters)
mlik.estimator = 2
mlik.ref = inla.evaluate(r$mode$theta, r)$mlik[mlik.estimator] + 
               (dgamma(exp(r$mode$theta[1]), shape = 100, rate = 1, log=TRUE) + r$mode$theta[1]) +
	   		(dgamma(exp(r$mode$theta[2]), shape = 1, rate = 1, log=TRUE) + r$mode$theta[2]) +
	    		(scaledBeta(((exp(r$mode$theta[3])-1)/(exp(r$mode$theta[3])+1)), 5, 1, log=TRUE) + 
							log(abs((2*exp(r$mode$theta[3]))/((exp(r$mode$theta[3])+1)^2))))


### Generate Koroov point set and calculate function evaluations
### Need - shift.koro(...), inla.evaluate(...)
### Parameters

### Number of points to evaluate function
npoints = 512

korobov.non = shift.koro(npoints, len.theta, 19, FALSE)
x11(50,50); pairs(korobov.non, pch=16)

#Low and High based on INLA "where the bulk lies" limits
low = c(min(theta.inla.hyperpar1[,1]), min(theta.inla.hyperpar2[,1]), min(theta.inla.hyperpar3[,1]))
high = c(max(theta.inla.hyperpar1[,1]), max(theta.inla.hyperpar2[,1]), max(theta.inla.hyperpar3[,1]))

### Transform pointsets

korobov = trans.pset(korobov.non, low, high)
res1 = matrix(NA, npoints, len.theta+1)

### Compute function evaluations
for(i in 1:npoints) {

	theta.new = korobov[i,]
    
## compute the relative posterior based on the Laplace approximation. ## Since we are rerunning
## with fixed=TRUE (above), the priors for the hyperparameters are 
## not included, so we need to add those.

     r.new = inla.evaluate(theta.new, r)
    lpost.rel = r.new$mlik[mlik.estimator] - mlik.ref +
               (dgamma(exp(theta.new[1]), shape = 100, rate = 1, log=TRUE) + theta.new[1]) +
			(dgamma(exp(theta.new[2]), shape = 1, rate = 1, log=TRUE) + theta.new[2]) +
	    		(scaledBeta(((exp(theta.new[3])-1)/(exp(theta.new[3])+1)), 5, 1, log=TRUE) + 
				log(abs((2*exp(theta.new[3]))/((exp(theta.new[3])+1)^2))))

## lpost.rel are the function evaluations (log) for the posterior 
## adding the log hyperpriors and subtracting the log marginal likelihood ## computed before.

    cat(i, "Evaluate theta.new", theta.new, "with relative posterior",
        lpost.rel, "\n")
   	 res1[i, ] = c(theta.new, lpost.rel)
}

#########################################
### Initial Approximation (Quadratic) ###
#########################################

### Number of partitions, partition position and degree (2)

parts = 15
position = 2
poly.degree = 2

### Finding marginals when function evaluations are in log-scale...

psi1 = res1[,c(1,len.theta+1)]
psi1 = psi1[order(psi1[,1]),]
psi2 = res1[,c(2,len.theta+1)]
psi2 = psi2[order(psi2[,1]),]
psi3 = res1[,c(3,len.theta+1)]
psi3 = psi3[order(psi3[,1]),]

psi1.parts.exp = partition(cbind(psi1[,1], exp(psi1[,2])), c(low[1], high[1]), parts, position)
psi2.parts.exp = partition(cbind(psi2[,1], exp(psi2[,2])), c(low[2], high[2]), parts, position)
psi3.parts.exp = partition(cbind(psi3[,1], exp(psi3[,2])), c(low[3], high[3]), parts, position)

psi1.parts = cbind(psi1.parts.exp[,1], log(psi1.parts.exp[,2]))
psi2.parts = cbind(psi2.parts.exp[,1], log(psi2.parts.exp[,2]))
psi3.parts = cbind(psi3.parts.exp[,1], log(psi3.parts.exp[,2]))

##########################################################################

van.partM1 = vandermonde.matrix(psi1.parts[,1], poly.degree)
van.partM2 = vandermonde.matrix(psi2.parts[,1], poly.degree)
van.partM3 = vandermonde.matrix(psi3.parts[,1], poly.degree)

gramian.part1 = t(van.partM1)%*%van.partM1
gramian.part2 = t(van.partM2)%*%van.partM2
gramian.part3 = t(van.partM3)%*%van.partM3

## Least squares polynomial

marg1.beta.part = qr.solve(gramian.part1, tol = 1e-32)%*%t(van.partM1)%*%psi1.parts[,2]
marg2.beta.part = qr.solve(gramian.part2, tol = 1e-32)%*%t(van.partM2)%*%psi2.parts[,2]
marg3.beta.part = qr.solve(gramian.part3, tol = 1e-32)%*%t(van.partM3)%*%psi3.parts[,2]

l.o = 1000

pt.part1 = seq(low[1], high[1], length.out = l.o)
pt.part2 = seq(low[2], high[2], length.out = l.o)
pt.part3 = seq(low[3], high[3], length.out = l.o)

marg1.part.pred = vandermonde.matrix(pt.part1, poly.degree)%*%marg1.beta.part
marg2.part.pred = vandermonde.matrix(pt.part2, poly.degree)%*%marg2.beta.part
marg3.part.pred = vandermonde.matrix(pt.part3, poly.degree)%*%marg3.beta.part

theta.poly.part1 = cbind(pt.part1, marg1.part.pred)
theta.poly.part1 = theta.poly.part1[order(theta.poly.part1[,1]),]
theta.poly.part2 = cbind(pt.part2, marg2.part.pred)
theta.poly.part2 = theta.poly.part2[order(theta.poly.part2[,1]),]
theta.poly.part3 = cbind(pt.part3, marg3.part.pred)
theta.poly.part3 = theta.poly.part3[order(theta.poly.part3[,1]),]

lines.part1 = seq(low[1], high[1], length.out = parts + 1)
lines.part2 = seq(low[2], high[2], length.out = parts + 1)
lines.part3 = seq(low[3], high[3], length.out = parts + 1)

x11(30,10); par(mfrow=c(1,3))
plot(psi1, pch=16, main = "function evals", col="light blue")
points(psi1.parts, pch=16, col="red")
lines(theta.poly.part1, col="black", lwd=1.5)
abline(v = lines.part1, col = "green")

plot(psi2, pch=16, main = "function evals", col="light blue")
points(psi2.parts, pch=16, col="red")
lines(theta.poly.part2, col="black", lwd=1.5)
abline(v = lines.part2, col = "green")

plot(psi3, pch=16, main = "function evals", col="light blue")
points(psi3.parts, pch=16, col="red")
lines(theta.poly.part3, col="black", lwd=1.5)
abline(v = lines.part3, col = "green")

### Estimate plotted with p-w means

x11(30,10); par(mfrow=c(1,3))
plot(psi1.parts, pch=16, col="red")
lines(theta.poly.part1, col="black", lwd=1.5)
abline(v = lines.part1, col = "green")

plot(psi2.parts, pch=16, col="red")
lines(theta.poly.part2, col="black", lwd=1.5)
abline(v = lines.part2, col = "green")

plot(psi3.parts, pch=16, col="red")
lines(theta.poly.part3, col="black", lwd=1.5)
abline(v = lines.part3, col = "green")

### Proper theta approximations --> HP approximations

theta.lds.part1 = cbind(pt.part1, exp(marg1.part.pred))
theta.ppn.const1 = diff(range(theta.lds.part1[,1]))*mean(theta.lds.part1[,2])
theta.lds.part1 = cbind(theta.lds.part1[,1], theta.lds.part1[,2]/theta.ppn.const1)

lds.part1 = cbind(exp(theta.lds.part1[,1]), theta.lds.part1[,2])
hp.ppn.const1 = diff(range(lds.part1[,1]))*mean(lds.part1[,2])
lds.part1 = cbind(lds.part1[,1], lds.part1[,2]/hp.ppn.const1)

theta.lds.part2 = cbind(pt.part2, exp(marg2.part.pred))
theta.ppn.const2 = diff(range(theta.lds.part2[,1]))*mean(theta.lds.part2[,2])
theta.lds.part2 = cbind(theta.lds.part2[,1], theta.lds.part2[,2]/theta.ppn.const2)

lds.part2 = cbind(exp(theta.lds.part2[,1]), theta.lds.part2[,2])
hp.ppn.const2 = diff(range(lds.part2[,1]))*mean(lds.part2[,2])
lds.part2 = cbind(lds.part2[,1], lds.part2[,2]/hp.ppn.const2)

theta.lds.part3 = cbind(pt.part3, exp(marg3.part.pred))
theta.ppn.const3 = diff(range(theta.lds.part3[,1]))*mean(theta.lds.part3[,2])
theta.lds.part3 = cbind(theta.lds.part3[,1], theta.lds.part3[,2]/theta.ppn.const3)

lds.part3 = cbind(exp(theta.lds.part3[,1]), theta.lds.part3[,2])
hp.ppn.const3 = diff(range(lds.part3[,1]))*mean(lds.part3[,2])
lds.part3 = cbind(lds.part3[,1], lds.part3[,2]/hp.ppn.const3)

#### Some plotting stuff ###

max.theta.ylim1 = max(c(theta.inla.hyperpar1[,2], theta.lds.part1[,2]))
max.theta.ylim2 = max(c(theta.inla.hyperpar2[,2], theta.lds.part2[,2]))
max.theta.ylim3 = max(c(theta.inla.hyperpar3[,2], theta.lds.part3[,2]))

max.hp.ylim1 = max(c(inla_hyperpar1[,2], lds.part1[,2]))
max.hp.ylim2 = max(c(inla_hyperpar2[,2], lds.part2[,2]))
max.hp.ylim3 = max(c(inla_hyperpar3[,2], lds.part3[,2]))

### Plots ###

x11(30,30); par(mfrow = c(2,2))
plot(theta.inla.hyperpar1, type="l", lwd = 2, ylim = c(0,max.theta.ylim1*1.05), cex.lab = 1.25,
		xlab = "theta_1")
lines(theta.lds.part1, type="l", col = "red", lwd = 2)
abline(v = log(100), col="green")

plot(theta.inla.hyperpar2, type="l", lwd = 2, ylim = c(0,max.theta.ylim2*1.05), cex.lab = 1.25,
		xlab = "theta_2")
lines(theta.lds.part2, type="l", col = "red", lwd = 2)
abline(v = log(1), col="green")

plot(theta.inla.hyperpar3, type="l", lwd = 2, ylim = c(0,max.theta.ylim3*1.05), cex.lab = 1.25,
		xlab = "theta_3")
lines(theta.lds.part3, type="l", col = "red", lwd = 2)
abline(v = log((1+0.65)/(1-0.65)), col="green")

plot(0,0,col="white")
text(0,0, cex = 1.5,
	"THETAS \n Black is inla.hyperpar \n Red is LDS-polynomial \n Green is the true value")

########################
### Cubic Correction ###
########################

### Polynomial fit at abscissa points
quad.poly1 = van.partM1%*%marg1.beta.part
quad.poly2 = van.partM2%*%marg2.beta.part
quad.poly3 = van.partM3%*%marg3.beta.part

### residuals = poly - pointwise means
resids1 = quad.poly1 - psi1.parts[,2]
resids2 = quad.poly2 - psi2.parts[,2]
resids3 = quad.poly3 - psi3.parts[,2]

ppdeg = 3

### get least squares beta estimate...
### Vandermonde matrix is cubic..

vR1 = vandermonde.matrix(psi1.parts[,1], ppdeg)
vR2 = vandermonde.matrix(psi2.parts[,1], ppdeg)
vR3 = vandermonde.matrix(psi3.parts[,1], ppdeg)

another.beta1 = qr.solve(t(vR1)%*%vR1, tol = 1e-32)%*%t(vR1)%*%resids1
another.beta2 = qr.solve(t(vR2)%*%vR2, tol = 1e-32)%*%t(vR2)%*%resids2
another.beta3 = qr.solve(t(vR3)%*%vR3, tol = 1e-32)%*%t(vR3)%*%resids3

corrected.beta1 = rbind(marg1.beta.part,0) - another.beta1
corrected.beta2 = rbind(marg2.beta.part,0) - another.beta2
corrected.beta3 = rbind(marg3.beta.part,0) - another.beta3

## Least squares polynomial

marg1.corr.pred = vandermonde.matrix(pt.part1, ppdeg)%*%corrected.beta1
marg2.corr.pred = vandermonde.matrix(pt.part2, ppdeg)%*%corrected.beta2
marg3.corr.pred = vandermonde.matrix(pt.part3, ppdeg)%*%corrected.beta3

l.o = 1000

pt.part1 = seq(low[1], high[1], length.out = l.o)
pt.part2 = seq(low[2], high[2], length.out = l.o)
pt.part3 = seq(low[3], high[3], length.out = l.o)

theta.poly.corr1 = cbind(pt.part1, marg1.corr.pred)
theta.poly.corr1 = theta.poly.corr1[order(theta.poly.corr1[,1]),]
theta.poly.corr2 = cbind(pt.part2, marg2.corr.pred)
theta.poly.corr2 = theta.poly.corr2[order(theta.poly.corr2[,1]),]
theta.poly.corr3 = cbind(pt.part3, marg3.corr.pred)
theta.poly.corr3 = theta.poly.corr3[order(theta.poly.corr3[,1]),]

lines.part1 = seq(low[1], high[1], length.out = parts + 1)
lines.part2 = seq(low[2], high[2], length.out = parts + 1)
lines.part3 = seq(low[3], high[3], length.out = parts + 1)

x11(30,10); par(mfrow=c(1,3))
plot(psi1, pch=16, main = "function evals", col="light blue")
points(psi1.parts, pch=16, col="red")
lines(theta.poly.corr1, col="black", lwd=1.5)
abline(v = lines.part1, col = "green")

plot(psi2, pch=16, main = "function evals", col="light blue")
points(psi2.parts, pch=16, col="red")
lines(theta.poly.corr2, col="black", lwd=1.5)
abline(v = lines.part2, col = "green")

plot(psi3, pch=16, main = "function evals", col="light blue")
points(psi3.parts, pch=16, col="red")
lines(theta.poly.corr3, col="black", lwd=1.5)
abline(v = lines.part3, col = "green")

### Estimate plotted with p-w means

x11(30,10); par(mfrow=c(1,3))
plot(psi1.parts, pch=16, col="red", cex = 1.5, xlab="", ylab="", main = "Theta(Tau_y))", cex.main=2)
lines(theta.poly.part1, col="black", lwd=2)
lines(theta.poly.corr1, col='blue', lty=2, lwd=2)
legend("topleft",
	c("Initial", "Cubic-Cor"), col = c("black","blue"), lwd=c(2,2), lty=c(1,2), cex=1.5)

plot(psi2.parts, pch=16, col="red", cex = 1.5, xlab="", ylab="", main = "Theta(Kappa))", cex.main=2)
lines(theta.poly.part2, col="black", lwd=2)
lines(theta.poly.corr2, col='blue', lty=2, lwd=2)
legend("topleft",
	c("Initial", "Cubic-Cor"), col = c("black","blue"), lwd=c(2,2), lty=c(1,2), cex=1.5)


plot(psi3.parts, pch=16, col="red", cex = 1.5, xlab="", ylab="", main = "Theta(Rho))", cex.main=2)
lines(theta.poly.part3, col="black", lwd=2)
lines(theta.poly.corr3, col='blue', lty=2, lwd=2)
legend("topleft",
	c("Initial", "Cubic-Cor"), col = c("black","blue"), lwd=c(2,2), lty=c(1,2), cex=1.5)



### Proper theta approximations --> HP approximations

theta.lds.part1 = cbind(pt.part1, exp(marg1.part.pred))
theta.ppn.const1 = diff(range(theta.lds.part1[,1]))*mean(theta.lds.part1[,2])
theta.lds.part1 = cbind(theta.lds.part1[,1], theta.lds.part1[,2]/theta.ppn.const1)

lds.part1 = cbind(exp(theta.lds.part1[,1]), theta.lds.part1[,2])
hp.ppn.const1 = diff(range(lds.part1[,1]))*mean(lds.part1[,2])
lds.part1 = cbind(lds.part1[,1], lds.part1[,2]/hp.ppn.const1)

theta.lds.part2 = cbind(pt.part2, exp(marg2.part.pred))
theta.ppn.const2 = diff(range(theta.lds.part2[,1]))*mean(theta.lds.part2[,2])
theta.lds.part2 = cbind(theta.lds.part2[,1], theta.lds.part2[,2]/theta.ppn.const2)

lds.part2 = cbind(exp(theta.lds.part2[,1]), theta.lds.part2[,2])
hp.ppn.const2 = diff(range(lds.part2[,1]))*mean(lds.part2[,2])
lds.part2 = cbind(lds.part2[,1], lds.part2[,2]/hp.ppn.const2)

theta.lds.part3 = cbind(pt.part3, exp(marg3.part.pred))
theta.ppn.const3 = diff(range(theta.lds.part3[,1]))*mean(theta.lds.part3[,2])
theta.lds.part3 = cbind(theta.lds.part3[,1], theta.lds.part3[,2]/theta.ppn.const3)

lds.part3 = cbind((exp(theta.lds.part3[,1])-1)/(exp(theta.lds.part3[,1])+1), theta.lds.part3[,2])
hp.ppn.const3 = diff(range(lds.part3[,1]))*mean(lds.part3[,2])
lds.part3 = cbind(lds.part3[,1], lds.part3[,2]/hp.ppn.const3)

### Proper correction plots too

theta.lds.corr1 = cbind(pt.part1, exp(marg1.corr.pred))
theta.corr.const1 = diff(range(theta.lds.corr1[,1]))*mean(theta.lds.corr1[,2])
theta.lds.corr1 = cbind(theta.lds.corr1[,1], theta.lds.corr1[,2]/theta.corr.const1)

lds.corr1 = cbind(exp(theta.lds.corr1[,1]), theta.lds.corr1[,2])
hp.corr.const1 = diff(range(lds.corr1[,1]))*mean(lds.corr1[,2])
lds.corr1 = cbind(lds.corr1[,1], lds.corr1[,2]/hp.corr.const1)

theta.lds.corr2 = cbind(pt.part2, exp(marg2.corr.pred))
theta.corr.const2 = diff(range(theta.lds.corr2[,1]))*mean(theta.lds.corr2[,2])
theta.lds.corr2 = cbind(theta.lds.corr2[,1], theta.lds.corr2[,2]/theta.corr.const2)

lds.corr2 = cbind(exp(theta.lds.corr2[,1]), theta.lds.corr2[,2])
hp.corr.const2 = diff(range(lds.corr2[,1]))*mean(lds.corr2[,2])
lds.corr2 = cbind(lds.corr2[,1], lds.corr2[,2]/hp.corr.const2)

theta.lds.corr3 = cbind(pt.part3, exp(marg3.corr.pred))
theta.corr.const3 = diff(range(theta.lds.corr3[,1]))*mean(theta.lds.corr3[,2])
theta.lds.corr3 = cbind(theta.lds.corr3[,1], theta.lds.corr3[,2]/theta.corr.const3)

lds.corr3 = cbind((exp(theta.lds.corr3[,1])-1)/(exp(theta.lds.corr3[,1])+1), theta.lds.corr3[,2])
hp.corr.const3 = diff(range(lds.corr3[,1]))*mean(lds.corr3[,2])
lds.corr3 = cbind(lds.corr3[,1], lds.corr3[,2]/hp.corr.const3)


#### Some plotting stuff ###

max.theta.ylim1 = max(c(theta.inla.hyperpar1[,2], theta.lds.part1[,2]))
max.theta.ylim2 = max(c(theta.inla.hyperpar2[,2], theta.lds.part2[,2]))
max.theta.ylim3 = max(c(theta.inla.hyperpar3[,2], theta.lds.part3[,2]))

max.hp.ylim1 = max(c(inla_hyperpar1[,2], lds.part1[,2]))
max.hp.ylim2 = max(c(inla_hyperpar2[,2], lds.part2[,2]))
max.hp.ylim3 = max(c(inla_hyperpar3[,2], lds.part3[,2]))

### Plots ###

x11(35,20); par(mfrow = c(2,3))
plot(theta.inla.hyperpar1, type="l", lwd = 2, ylim = c(0,max.theta.ylim1*1.05), cex.lab = 1.25,
		xlab = "", ylab="", main = "Theta(Tau_y)", cex.main = 2)
lines(theta.lds.part1, type="l", col = "red", lwd = 2)
lines(theta.lds.corr1, type="l", col = "blue", lty =2, lwd = 2)
abline(v = log(100), col="green")
legend("topleft",
		c("INLA-grid", "Initial", "C-Corr"), lty = c(1,1,2), lwd = c(2,2,2), 
		col = c("black","red", "blue"), cex = 1.5)

plot(theta.inla.hyperpar2, type="l", lwd = 2, ylim = c(0,max.theta.ylim2*1.05), cex.lab = 1.25,
		xlab = "", ylab="", main = "Theta(Kappa)", cex.main = 2)
lines(theta.lds.part2, type="l", col = "red", lwd = 2)
lines(theta.lds.corr2, type="l", col = "blue", lty =2, lwd = 2)
abline(v = log(1), col="green")
legend("topleft",
		c("INLA-grid", "Initial", "C-Corr"), lty = c(1,1,2), lwd = c(2,2,2), 
		col = c("black","red", "blue"), cex = 1.5)

plot(theta.inla.hyperpar3, type="l", lwd = 2, ylim = c(0,max.theta.ylim3*1.05), cex.lab = 1.25,
		xlab = "", ylab="", main = "Theta(Rho)", cex.main = 2)
lines(theta.lds.part3, type="l", col = "red", lwd = 2)
lines(theta.lds.corr3, type="l", col = "blue", lty =2, lwd = 2)
abline(v = log((1+0.65)/(1-0.65)), col="green")
legend("topleft",
		c("INLA-grid", "Initial", "C-Corr"), lty = c(1,1,2), lwd = c(2,2,2), 
		col = c("black","red", "blue"), cex = 1.5)

plot(inla.smarginal(r2$marginals.hyperpar[[1]]), 
		type="l", lwd = 2, cex.lab = 1.25, xlim = c(min(lds.part1[,1]), max(lds.part1[,1])),
		xlab = "", ylab="", main = "Tau_y", cex.main = 2)
lines(lds.part1, type="l", col = "red", lwd = 2)
lines(lds.corr1, type="l", col = "blue", lty =2, lwd = 2)
abline(v = 100, col="green")
legend("topleft",
		c("INLA-grid", "Initial", "C-Corr"), lty = c(1,1,2), lwd = c(2,2,2), 
		col = c("black","red", "blue"), cex = 1.5)

plot(inla.smarginal(r2$marginals.hyperpar[[2]]), 
		type="l", lwd = 2, cex.lab = 1.25, xlim = c(min(lds.part2[,1]), max(lds.part2[,1])),
		xlab = "", ylab="", main = "Kappa", cex.main = 2)
lines(lds.part2, type="l", col = "red", lwd = 2)
lines(lds.corr2, type="l", col = "blue", lty =2, lwd = 2)
abline(v = 1, col="green")
legend("topright",
		c("INLA-grid", "Initial", "C-Corr"), lty = c(1,1,2), lwd = c(2,2,2), 
		col = c("black","red", "blue"), cex = 1.5)

plot(inla.smarginal(r2$marginals.hyperpar[[3]]), 
		type="l", lwd = 2, cex.lab = 1.25, xlim = c(min(lds.part3[,1]), max(lds.part3[,1])),
		xlab = "", ylab="", main = "Rho", cex.main = 2)
lines(lds.part3, type="l", col = "red", lwd = 2)
lines(lds.corr3, type="l", col = "blue", lty =2, lwd = 2)
abline(v = 0.65, col="green")
legend("topleft",
		c("INLA-grid", "Initial", "C-Corr"), lty = c(1,1,2), lwd = c(2,2,2), 
		col = c("black","red", "blue"), cex = 1.5)



